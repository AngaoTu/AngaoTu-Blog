- [内存对齐](#内存对齐)
  - [1. <a name=''></a>什么是内存对齐](#1-什么是内存对齐)
  - [2. <a name='-1'></a>为什么要内存对齐](#2-为什么要内存对齐)
  - [3. <a name='-1'></a>内存对齐的规则](#3-内存对齐的规则)
  - [4. <a name='-1'></a>结构体中内存对齐](#4-结构体中内存对齐)
    - [4.1. <a name='sizeof'></a>sizeof](#41-sizeof)
    - [4.2. <a name='-1'></a>无嵌套](#42-无嵌套)
    - [4.3. <a name='-1'></a>有嵌套](#43-有嵌套)
  - [5. <a name='iOS'></a>iOS中对象内存对齐](#5-ios中对象内存对齐)
    - [5.1. <a name='iOS-1'></a>iOS中获取内存大小方式](#51-ios中获取内存大小方式)
    - [5.2. <a name='-1'></a>对象的内存对齐](#52-对象的内存对齐)
    - [5.3. <a name='-1'></a>内存优化](#53-内存优化)
    - [5.4. <a name='-1'></a>总结](#54-总结)
# 内存对齐

##  1. <a name=''></a>什么是内存对齐

- 元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每个元素放置到内存中时，它都会认为内存是按照自己的大小（通常它为4或8）来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始，这就是所谓的内存对齐。

##  2. <a name='-1'></a>为什么要内存对齐

- 有些`CPU`可以访问任意地址上的任意数据，而有些`CPU`只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了
- `CPU`每次寻址都是要消费时间的，并且`CPU` 访问内存时，是以字长（`word size`）为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能。这是一种以空间换时间的方法，目的降低`cpu`开销。
- 举例：
  - 假如没有内存对齐机制，数据可以任意存放，现在一个`int`变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器。这需要做很多工作。
  - 现在有了内存对齐的，`int`类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。

##  3. <a name='-1'></a>内存对齐的规则

> 每个特定平台上的编译器都有自己的默认"对齐系数"，常用平台默认对齐系数如下：(32位系统对齐系数是4，64位系统对齐系数是8)。这只是默认对齐系数，实际上对齐系数我们是可以修改的，程序员可以通过预编译命令`#pragma pack()`，n = 1, 2, 4, 8, 18来改变这一系数，其中的n就是你要指定的`“对齐系数”`。

1. 原则一：**数据成员对⻬规则**
   - 结构体（`struct`）或者联合体（`union`）的数据成员，第一个数据成员放在`offset为0`的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始（`比如 int 4字节，那么存储位置可以是0-4-8-12-16-20` 依次类推）
   - 数据成员的对齐规则可以理解为`min(m, n)` 的公式, 其中 `m`表示**当前成员的开始位置**, `n`表示**当前成员所需要的位数**。如果满足条件 `m 整除 n` （即 `m % n == 0`）,  `n 从 m` 位置开始存储, 反之继续检查`m+1 能否整除 n`, 直到可以整除, 从而就确定了当前成员的开始位置
2. 原则二：**数据成员为结构体**
   - 如果一个结构体里有某些结构体成员，则`该结构体成员`要从其**内部最大元素大小的整数倍地址**开始存储，比如`struct a`里有`struct b`， `b`里面有`char, int, double, short`，那么**b应该从8的整数倍地址**开始存储，即`最大成员为double 8字节`。
3. 原则三：**结构(或联合)的整体对齐规则**
   - 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照`#pragma pack`指定的数值和结构(或联合)最大数据成员长度中，比较小的整数倍
   - 比如说：编译器指定按照8字节对齐，然后结构体最大数据成员长度为4，最终按照4字节对齐

##  4. <a name='-1'></a>结构体中内存对齐

- 根据上面的内存对齐规则，我们探索一下结构体中内存对齐

###  4.1. <a name='sizeof'></a>sizeof

- `sizeof` 是一个`操作符`，不是函数
- 我们一般使用`sizeof`计算内存大小时，传入的对象主要是**数据类型**，这个是在编译阶段就会确定大小而不是运行时。`sizeof`最终得到的结果是**该数据类型占用空间的大小**

###  4.2. <a name='-1'></a>无嵌套

```objective-c
struct Struct1 {
    double a;
    char b;
    int c;
    short d;
}struct1;

struct Struct2 {
    double a;
    int b;
    char c;
    short d;
}struct2;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"%lu-%lu", sizeof(struct1), sizeof(struct2));
    }
    return 0;
}
```

> 打印结果：**内存对齐[8322:58962] 24-16**

- 根据结果发现，结构体中包含的变量相同，只是因为位置不一样，但是内存大小不一样
- 根据内存对齐原则，来分析一下结构体中成员的内存占用
- `Struct1`中：
  - 变量`a`: 占`8`个字节，`offset`从`0`开始， `min(0，8)`， 即`0 ~ 7`   存放`a`
  - 变量`b`: 占`1`个字节，`offset`从`8`开始， `min(8，1)`， 即`8`       存放`d`
  - 变量`c`: 占`4`个字节，`offset`从`9`开始， `min(9，4)`，`9 % 4 != 0`，继续往后移动直到找到可以整除`4`的位置 `12` 即`12 ~ 15` 存放`b`
  - 变量`d`: 占`2`个字节，`offset`从`16`开始，`min(16，2)`，即`16 ~ 17` 存放`c`
  - 实际占用18个字节，根据内存对齐原则三，结构体中最大变量`a`占用8字节，所有最终大小必须是8字节的倍数，最终占用24个字节
- `Struct2`中：
  - 变量`a`: 占`8`个字节，`offset`从`0`开始， `min(0，8)`， 即`0 ~ 7`   存放`a`
  - 变量`b`: 占`4`个字节，`offset`从`8`开始， `min(8，4)`， 即`8 ~ 11`  存放`b`
  - 变量`c`: 占`2`个字节，`offset`从`12`开始，`min(12，2)`，即`12 ~ 13` 存放`c`
  - 变量`d`: 占`1`个字节，`offset`从`14`开始，`min(14，1)`，即`14` 存放`d` 
  - 实际占用了15个字节，根据内存对齐原则三，结构体中最大变量`a`占用8字节，所有最终大小必须是8字节的倍数，最终占用16个字节。

###  4.3. <a name='-1'></a>有嵌套

```objective-c
struct Struct2 {
    double a;
    int b;
    char c;
    short d;
}struct2;

struct Struct3 {
    double a;
    char b;
    int c;
    short d;
    struct Struct2 str;
}struct3;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"%lu-%lu", sizeof(struct2), sizeof(struct3));
    }
    return 0;
}
```

> 打印结果：**内存对齐[36173:182032] 16-40**

- `Struct3`中：
  - 变量`a`: 占`8`个字节，`offset`从`0`开始， `min(0，8)`， 即`0 ~ 7`   存放`a`
  - 变量`b`: 占`4`个字节，`offset`从`8`开始， `min(8，4)`， 即`8 ~ 11`  存放`b`
  - 变量`c`: 占`2`个字节，`offset`从`12`开始，`min(12，2)`，即`12 ~ 13` 存放`c`
  - 变量`d`: 占`1`个字节，`offset`从`14`开始，`min(14，1)`，即`14` 存放`d` 
  - 变量`str`，由于它是结构体变量，根据内存对齐规则二：**结构体成员要从其内部最大元素大小的整数倍地址开始存储**。结构体中最大变量占8字节，所以`offset`需要从16开始，`Struct2`的内存大小是18字节。所以`min(16, 18)`，即16-33存放`str`
  - 实际内存大小是34字节，根据内存对齐原则三，结构体中最大变量`a`占用8字节，所有最终大小必须是8字节的倍数，最终占用40个字节

##  5. <a name='iOS'></a>iOS中对象内存对齐

###  5.1. <a name='iOS-1'></a>iOS中获取内存大小方式

1. `sizeof()`在上一小节已经讲述
2. `class_getInstanceSize()`
   - 获取的是一个对象实际占用的内存空间，内存大小由成员变量决定。这里使用了8字节对齐
3. `malloc_size()`
   - 获取的是系统实际给开辟的内存空间大小，采用了16字节对齐。

###  5.2. <a name='-1'></a>对象的内存对齐

- 由于`iOS`中对象的本质就是结构体，那么我们可以说对象的内存对齐就是结构体的内存对齐么？我们通过例子具体来探究一下

-  先定一个`Test`类，然后`Test`类里面的成员变量和`Struct1`保持一致

```objective-c
@interface Test : NSObject

@property (nonatomic, assign) double a;
@property (nonatomic, assign) char b;
@property (nonatomic, assign) int c;
@property (nonatomic, assign) short d;

@end

@implementation Test

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Test *test = [Test alloc];
        test.a = 10.0;
        test.b = 'a';
        test.c = 12;
        test.d = 100;
        
        NSLog(@"struct1 = %lu Test = %lu",sizeof(struct1), class_getInstanceSize([test class]));
    }
    return 0;
}
```

> 打印结果：**内存对齐[42277:218736] struct1 = 24 Test = 24**

- 在`Test`类中定义的变量和`struct2`中顺序是一样的，但是`test`对象会多带一个`isa_t`变量，该变量占8个字节。打印结果显示它们的大小是一样的，说明`test`对象我们定义的变量直占了16个字节。明明和结构体顺序、类型都一样的，为什么对象占用的内存和结构体却不一样。这是因为苹果的内存优化机制

###  5.3. <a name='-1'></a>内存优化

- 我们具体看一下它是如何进行内存优化的：

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h55e4qi0s7j219q0d6q4k.jpg)

- 通过`lldb`断点打印可以看出，`a`的读取是通过**0x4024000000000000**，`b`的读取是通过**0x0061**，`c`的读取是通过**0x0000000c**，`d`的读取是通过**0x0064**。我们可以发现`char b; int c; short d;`共用了一个8字节空间。
- 苹果采用**时间换空间**的方式，通过对对象的属性存储顺序进行重排，达到内存优化的目的。

###  5.4. <a name='-1'></a>总结

- 为了提高`cpu`的存储效率和安全访问，制定了内存对齐规则。但是也因为内存对齐，从而浪费了很多内存。苹果为了内存优化尽可能降低内存的浪费，使用了**属性重排**的方式。
- 既保证了存储的效率，又减少了内存的浪费。
